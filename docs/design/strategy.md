# 策略模式

## 一、概述

策略模式 `（Strategy Pattern）` 是一种行为型设计模式，它定义了一系列算法，并将每个算法封装起来，使得它们可以互相替换。策略模式可以让算法独立于使用它的客户端而变化。在软件开发中，策略模式通常用来处理算法的变化。

在 `JavaScript` 中，策略模式通常用于替代条件语句，即把多个条件分支的代码块抽取出来，通过不同的策略对象来执行不同的代码块。

## 二、实现方式

策略模式通常由两个部分组成：

- 策略类：实现了具体的算法。
- 环境类（或上下文类）：维护一个对策略对象的引用，提供一个接口供客户端调用。

## 三、优缺点

### 1. 优点

- 策略模式可以将算法的实现与客户端代码分离，使得算法的变化不影响客户端的代码。
- 策略模式可以避免使用大量的条件语句，使代码更加简洁、易于维护和扩展。
- 策略模式可以提高代码的复用性，不同的策略类可以被多个客户端共享。
- 策略模式可以方便地进行单元测试，每个策略类都可以被单独测试。

### 2. 缺点

- 客户端需要知道所有的策略类，选择合适的策略类需要一定的判断逻辑，增加了客户端的复杂性。
- 如果策略类数量过多，会导致类的数量增加，系统的复杂性也会增加。

## 四、适用场景

策略模式适用于以下场景：

- 当一个对象需要根据不同的情况执行不同的代码逻辑时，可以使用策略模式来封装这些不同的代码逻辑，使得代码更加简洁和易于维护。。
- 当一个函数或方法需要有多个条件分支时，可以使用策略模式来避免嵌套过多的 if/else 语句，提高代码的可读性和可维护性。
- 当需要在运行时动态地选择算法时，可以使用策略模式来方便地进行算法的切换和选择。

## 五、例子

在函数式编程中，策略模式通常通过函数实现。下面是一个使用 JavaScript 实现策略模式的示例代码：

> 绩效为 S 的人年终奖有 4 倍工资，绩效为 A 的人年终奖有 3 倍工资，绩效为 B 的人年终奖有 2 倍工资。

首先，我们定义了三个绩效策略函数，分别对应 S、A、B 级绩效，它们都接受一个工资参数，并返回年终奖金额。

```js
// 定义绩效策略函数
const performanceS = (salary) => salary * 4
const performanceA = (salary) => salary * 3
const performanceB = (salary) => salary * 2
```

然后我们定义了一个年终奖函数 `bonus`，它接受工资和绩效策略函数两个参数，并调用传递进来的绩效策略函数来计算年终奖金额。

```js
// 定义年终奖函数
const bonus = (salary, performance) => performance(salary)
```

在使用过程中，我们直接调用了 `bonus` 函数，并传递了工资和绩效策略函数，即可获取年终奖金额。

```js
// 使用示例
const salary = 10000
console.log('S 级绩效年终奖为：', bonus(salary, performanceS)) // 40000
console.log('A 级绩效年终奖为：', bonus(salary, performanceA)) // 30000
console.log('B 级绩效年终奖为：', bonus(salary, performanceB)) // 20000
```

## 六、总结

策略模式是一种行为型设计模式，它能够让你定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户端。

`JavaScript` 中，策略模式通常用于替代条件语句，即把多个条件分支的代码块抽取出来，通过不同的策略对象来执行不同的代码块。我们可以通过对象字面量、函数声明或者类声明等方式来定义策略对象，然后在使用时通过传递不同的参数来选择对应的策略。使用策略模式可以提高代码复用和可维护性，同时也使代码更加灵活和可扩展。

需要注意的是，策略模式虽然可以使代码更加灵活，但同时也带来了一定的复杂性，需要根据具体的情况进行权衡和选择。

最后，使用策略模式需要注意避免过度设计，只有在实际开发中遇到多个条件分支或者需要动态选择算法的具体情况时才需要使用。在其他场景下，简单的条件分支或者函数调用可能更为适合。
